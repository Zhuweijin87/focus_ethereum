package manage 

import (
	"testing"
	"time"

	"gitee.com/nerthus/nerthus/common"
	"gitee.com/nerthus/nerthus/common/test"
	"gitee.com/nerthus/nerthus/db"
)

type witness struct {
	address  common.Address
	joinDate time.Time
	integral  int64
	bail 	  int64
	flag 	  bool
}

var defaultWitness = []witness{
	{
		common.HexToAddress("095e7b1ea6a6c7c4c2d2eb977ef3c326af552d87"),
		time.Now(),
		100,
		10000,
		true,
	},
	{
		common.HexToAddress("b94f5374fce5ed0c8e2a8697c15331677e6ebf0b"),
		time.Now(),
		103,
		12000,
		false,
	},
	{
		common.HexToAddress("4e2a5374fce5e6bc8e2a8697c15331677e6ebf45"),
		time.Now(),
		100,
		9000,
		true,
	},
	{
		common.HexToAddress("812a5374fce5453b8e2a8697c15331677e6ebf45"),
		time.Now().Add(-10 * time.Minute),
		102,
		11000,
		true,
	},
}

var defaultContractAddr = common.HexToAddress("1111111111111111111111111111111111111111")

func newtestHash() {

}

func initCoinFlow(addr common.Address, db *db.Database, t *testing.T) {
	err := db.Execute("insert into coin_flow values(?,?,?,?,?,?,?,?)", addr.Hash().String(), addr.String(),
		defaultContractAddr.Hash().String(), 12000, AddressCoinTransIn, 1, 0, 1)
	if err != nil {
		t.Error("Fail to execute:", err)
	}

	defer func() {
		db.Execute("delete from coin_flow")
	}()
}

func TestApplyProcedure(t *testing.T) {
	db := test.InitDB(t, "mysql")
	defer db.Close()

	for _, v := range defaultWitness {
		if v.flag {
			err := db.Execute("insert into witness(address, join_date, status, weight, bail) values(?,?,?,?,?)",
				v.address.String(), v.joinDate, WitnessOfNormalState, v.integral, v.bail)
			if err != nil {
				t.Errorf("Fail to insert data:%v", err)
			}
		}
	}

	// 清理数据
	defer func() {
		db.Execute("delete from witness")
	}()

	// check witness not apply
	if result := checkApplyRecord(db, defaultWitness[0].address); !result {
		t.Fatalf("Fail to apply with having not been to be witness")
	}

	if result := checkApplyRecord(db, defaultWitness[1].address); result {
		t.Fatalf("Fail to apply with having been to be witness")
	}

	initCoinFlow(defaultWitness[0].address, db, t)

	if result := checkBailValid(db, defaultWitness[0].address, defaultWitness[0].bail); result {
		t.Fatalf("Fail to check bail validate")
	}

	if result := checkBailValid(db, defaultWitness[2].address, defaultWitness[2].bail); !result {
		t.Fatalf("Fail to check bail with balance insufficient")
	}
} 

func TestWitnessApply(t *testing.T) {
	db := test.InitDB(t, "mysql")
	defer db.Close()

	wManager := New(db, defaultContractAddr)

	test := defaultWitness[0]

	payload1, app, ok := wManager.Apply(test.address, test.bail)
	if !ok {
		t.Fatalf("Fail to apply")
	}

	if app != "contract" {
		t.Fatalf("unit type is not contract")
	}

	payload2, app, ok := wManager.ValidApply(payload1)
	if !ok {
		t.Fatalf("Fail to valid apply unit")
	}

	if app != "witness" {
		t.Fatalf("unit type is not witness")
	}

	apply, ok := payload1.(*WitnessArgs)
	if !ok {
		t.Fatalf("payload is not WitnessArgs")
	}

	valid, ok := payload2.(*WitnessArgs)
	if !ok {
		t.Fatalf("payload is not WitnessArgs")
	}

	if valid.From != apply.From {
		t.Errorf("Validate from address not match")
	}

	if valid.To != apply.To {
		t.Errorf("Validate to address not match")
	}
}
