// AUthor:   zwj@2017-11-06

// 见证人管理 
package manage

import (
	"time"
	"errors"

	"gitee.com/nerthus/nerthus/db"
	"gitee.com/nerthus/nerthus/log"
	"gitee.com/nerthus/nerthus/common"
	"gitee.com/nerthus/nerthus/core/types"
	_ "gitee.com/nerthus/nerthus/rlp"
	_ "fmt"
)

var (
	LowestAmountOfBail = 10000   // 最低保证金

	AddressCoinTransIn = 1 		 // 转入标识 
	AddressCoinTransOut = 2 	 // 转出标识

	WitnessOfNormalState = 0 		// 见证人正常状态
	WitnessOfCancelState = 1 		// 见证人已注销
)

var (
	ErrHasApplyWitness = errors.New("Has applied to be witness")
)

type WitnessManager struct {
	db 	*db.Database
	addr  common.Address  // 合约地址
}

// 见证单元参数
type WitnessArgs struct {
	From  common.Address  // 来源地址
	To    common.Address  // 目的地址
	Amount int64
	Result bool
}

func New(db *db.Database, contract common.Address) *WitnessManager {
	return &WitnessManager{db:db, addr:contract}
}

// 申请见证人单元
func (wm *WitnessManager) Apply(from common.Address, bail int64) (types.PayLoad, string, bool) {
	args := WitnessArgs {
		From: from,
		To: wm.addr,
		Amount: bail,
	}

	return &args, "contract", true
}

func (args *WitnessArgs) OutputAddress() []common.Address {
	var outAddr []common.Address
	outAddr = append(outAddr, args.To)
	return outAddr
}

// 验证申请见证人
func (wm *WitnessManager) ValidApply(payload types.PayLoad) (types.PayLoad, string, bool) {
	args, ok := payload.(*WitnessArgs)
	if !ok {
		log.Error("payload type is not WitnessArgs")
		return nil, "", false
	}

	out := WitnessArgs {
		From: args.From,
		To: args.To,
		Amount: args.Amount,
		Result: true,
	}

	if checkApplyRecord(wm.db, args.From) {
		out.Result = false
	}

	if !checkBailValid(wm.db, args.From, args.Amount) {
		out.Result = false
	}

	return &out, "witness", true
}

// 注销申请
func (wm *WitnessManager) Cancel(target common.Address) (types.PayLoad, string, bool) {
	payload := WitnessArgs{
		From: wm.addr,
		To: target,
	}

	return &payload, "contract", true
}

// 验证见证人注销
func (wm *WitnessManager) ValidCancel(payload types.PayLoad) (types.PayLoad, string, bool) {
	args, ok := payload.(*WitnessArgs)
	if !ok {
		log.Error("payload type is not WitnessArgs")
		return nil, "", false
	}

	out := WitnessArgs{
		From: args.From,
		To: args.To,
		Result: true,
	}

	if !checkWitnessStatus(wm.db, args.To) {
		args.Result = false
	}

	if !checkWitUnitTime(wm.db, args.To) {
		args.Result = false
	}

	balanceOfBail, ok := getWitnessBalanceOfBail(wm.db, args.To)
	if !ok {
		args.Result = false
	}

	out.Amount = balanceOfBail

	if args.Result {
		// update witness
	}

	return &out, "witness", true
}

// 检验是否申请过见证人 
func checkApplyRecord(db *db.Database, addr common.Address) bool {
	row, err := db.QueryOne("select count(1) from witness where address=?", addr.String())
	if err != nil {
		log.Error("Fail to query witness:", err)
		return true  
	}

	var exist int 
	err = row.ScanRow(&exist)
	if err != nil {
		log.Error("Fail to ScanRow:", err)
		return true  
	}

	if exist > 0 {
		log.Error("Has applied to be witness")
		return true
	}

	return false  
} 

// 验证保证金是否有效
func checkBailValid(db *db.Database, addr common.Address, bail int64) bool {
	if int64(LowestAmountOfBail) < bail {
		log.Error("Bail is out of lowest amount")
		return false 
	}

	balance, err := getAddressBalance(db, addr)
	if err != nil {
		return false  
	}

	if balance < bail {
		log.Error("Balance is insufficient")
		return false
	}

	return true 
}

// 获取账户余额 
func getAddressBalance(db *db.Database, addr common.Address) (int64, error) {
	totalTransIn, err := getTotalAmountByCreditFlag(db, addr, AddressCoinTransIn)
	if err != nil {
		return 0, err 
	}

	totalTransOut, err := getTotalAmountByCreditFlag(db, addr, AddressCoinTransOut)
	if err != nil {
		return 0, err 
	}

	return totalTransIn - totalTransOut, nil
}

// 根据记账方式算出总金额
func getTotalAmountByCreditFlag(db *db.Database, addr common.Address, isCredit int) (int64, error) {
	row, err := db.QueryOne("select sum(amount) from coin_flow where address=? and is_credit=?", addr.String(), isCredit)
	if err != nil {
		log.Error("Fail to query:", err)
		return 0, err 
	}

	var total int64 
	err = row.ScanRow(&total)
	if err != nil {
		log.Error("Fail to fetch:", err)
		return 0, err 
	}

	return total, nil 
}

// 验证见证人状态
func checkWitnessStatus(db *db.Database, addr common.Address) bool {
	row, err := db.QueryOne("select status, join_date from witness where address=?", addr.String())
	if err != nil {
		log.Error("Fail to query witness:", err)
		return false 
	}

	var (
		status int 
		join_date time.Time
	)
	err = row.ScanRow(&status, &join_date)
	if err != nil {
		log.Error("Fail to fetch:", err)
		return false 
	}

	if status != WitnessOfNormalState {
		return false
	}

	if time.Since(join_date).Seconds() <= float64(10 * 60 + 0.01) {
		log.Error("Can't cancel within 10 minutes after apply")
		return false
	}

	return true 
}

// 注销时，见证单元时间校验
func checkWitUnitTime(db *db.Database, target common.Address) bool {
	row, err := db.QueryOne("select confirm_date from coin_flow where address=? order by confirm_date", target.String())
	if err != nil {
		log.Error("Fail to query:", err)
		return false 
	}

	var (
		confirm_date  time.Time 
	)

	err = row.ScanRow(&confirm_date)
	if err != nil {
		log.Error("Fail to scan:", err)
		return false 
	}

	//time.Now().Add(-10 * time.Minute).After(confirm_date)
	if time.Since(confirm_date).Seconds() <= float64(10 * 60 + 0.01) {
		log.Error("")
		return false 
	}
	return true
}

// 获取见证人保证金余额
func getWitnessBalanceOfBail(db *db.Database, target common.Address) (int64, bool) {
	row, err := db.QueryOne("select bail - fine from witness where address=?", target.String())
	if err != nil {
		log.Error("Fail to query:", err)
		return 0, false
	}

	var balance int64
	err = row.ScanRow(&balance)
	if err != nil {
		log.Error("Fail to scanrow:", err)
		return 0, false
	}

	return balance, false
}

// 注销后更新见证人状态
func updateWitnessAfterCancel(db *db.Database, target common.Address) bool {
	err := db.Execute("update witness set status=?, bail=? where address=?", WitnessOfCancelState, 0, target)
	if err != nil {
		log.Error("Fail to execute update:", err)
		return false
	}

	return true
}

// 存储新的见证人信息
func saveNewWitness(db *db.Database, addr common.Address, bail int64, integal int64) error {
	err := db.Execute("insert into witness values(?,?,?,?,?)", addr, time.Now())
	if err != nil {
		return err
	}

	return nil
}



-- Author : zwj@2017-10-13

-- 数据库语句 

-- 节点信息表
CREATE TABLE IF NOT EXISTS node (
    nodeid          varchar(128) NOT NULL,
    nodeinfo		blob NOT NULL,
	ping			timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	pong			timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	findfails		int,
	PRIMARY KEY		(nodeid)
);

-- 数据归档
CREATE TABLE IF NOT EXISTS env_archive (
	rawid 			tinyblob NOT NULL,
	envrlp 			blob NOT NULL
);

-- 见证人库
CREATE TABLE IF NOT EXISTS witness (
	address 	 	varchar(44) NOT NULL,
	join_date		timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
	cancel_date timestamp NULL,
	status 			int,
	weight 			int,
	bail        int,
	PRIMARY KEY 	(address)
);

-- 资金流水
CREATE TABLE IF NOT EXISTS coin_flow (
  unit_hash   varchar(64) NOT NULL,
  address     varchar(44) NOT NULL,
  src_unit_hash varchar(64) NOT NULL,
  amount  int,
  is_credit  int,
  typ   int,
  status int,
  idx  int,
  PRIMARY KEY  (unit_hash)
);
